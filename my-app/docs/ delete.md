Вы заметили интересную оптимизацию в методе удаления задачи. Это связано с особенностями работы массивов в Solidity и стоимостью газа:

### Почему такое удаление используется

1. **Экономия газа**: В Solidity операции, изменяющие состояние блокчейна, стоят газ. Чем сложнее операция, тем дороже.

2. **Нет встроенных методов удаления элемента по индексу**: В Solidity нет встроенных функций типа `remove()` или `splice()` для массивов, как в JavaScript.

3. **Проблема "дырок" в массиве**: Если просто установить элемент в `null` или удалить его, в массиве образуются пустые места, что усложняет итерацию и может вызвать ошибки.

### Как работает это решение

1. Мы берём последний элемент массива
2. Перемещаем его на место удаляемого элемента (если удаляемый элемент не последний)
3. Удаляем последний элемент с помощью `.pop()`

### Почему это эффективно

- **Сохраняет непрерывность массива**: Нет пустых мест
- **Минимальные операции**: Только одна запись и одно удаление 
- **Постоянная сложность O(1)**: Время выполнения не зависит от размера массива

### Альтернативы

Теоретически можно было бы реализовать удаление со сдвигом всех элементов (как в классических алгоритмах), но:
- Это потребовало бы цикла
- Каждая операция изменения состояния стоит газ
- Сложность была бы O(n), что очень дорого для больших массивов

Поэтому в Solidity почти всегда используют этот "трюк" с заменой на последний элемент, жертвуя порядком элементов ради эффективности.